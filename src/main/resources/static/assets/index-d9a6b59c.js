var Re = Object.defineProperty; var qe = (t, e, n) => e in t ? Re(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var ie = (t, e, n) => (qe(t, typeof e != "symbol" ? e + "" : e, n), n); (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const c of i) if (c.type === "childList") for (const u of c.addedNodes) u.tagName === "LINK" && u.rel === "modulepreload" && r(u) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const c = {}; return i.integrity && (c.integrity = i.integrity), i.referrerPolicy && (c.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? c.credentials = "include" : i.crossOrigin === "anonymous" ? c.credentials = "omit" : c.credentials = "same-origin", c } function r(i) { if (i.ep) return; i.ep = !0; const c = n(i); fetch(i.href, c) } })(); function S() { } function Ne(t, e) { for (const n in e) t[n] = e[n]; return t } function Ce(t) { return t() } function pe() { return Object.create(null) } function I(t) { t.forEach(Ce) } function ce(t) { return typeof t == "function" } function J(t, e) { return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function" } let Y; function he(t, e) { return t === e ? !0 : (Y || (Y = document.createElement("a")), Y.href = e, t === Y.href) } function Me(t) { return Object.keys(t).length === 0 } function Ie(t, ...e) { if (t == null) { for (const r of e) r(void 0); return S } const n = t.subscribe(...e); return n.unsubscribe ? () => n.unsubscribe() : n } function y(t, e) { t.appendChild(e) } function E(t, e, n) { t.insertBefore(e, n || null) } function k(t) { t.parentNode && t.parentNode.removeChild(t) } function _e(t, e) { for (let n = 0; n < t.length; n += 1)t[n] && t[n].d(e) } function w(t) { return document.createElement(t) } function x(t) { return document.createTextNode(t) } function $() { return x(" ") } function K() { return x("") } function xe(t, e, n, r) { return t.addEventListener(e, n, r), () => t.removeEventListener(e, n, r) } function j(t, e, n) { n == null ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n) } function He(t) { return Array.from(t.childNodes) } function Q(t, e) { e = "" + e, t.data !== e && (t.data = e) } function Be(t, e, { bubbles: n = !1, cancelable: r = !1 } = {}) { return new CustomEvent(t, { detail: e, bubbles: n, cancelable: r }) } function Z(t, e) { return new t(e) } let U; function B(t) { U = t } function ue() { if (!U) throw new Error("Function called outside component initialization"); return U } function Ue(t) { ue().$$.after_update.push(t) } function Ve(t) { ue().$$.on_destroy.push(t) } function Je() { const t = ue(); return (e, n, { cancelable: r = !1 } = {}) => { const i = t.$$.callbacks[e]; if (i) { const c = Be(e, n, { cancelable: r }); return i.slice().forEach(u => { u.call(t, c) }), !c.defaultPrevented } return !0 } } function me(t, e) { const n = t.$$.callbacks[e.type]; n && n.slice().forEach(r => r.call(this, e)) } const D = [], ge = []; let R = []; const be = [], Ae = Promise.resolve(); let le = !1; function Fe() { le || (le = !0, Ae.then(Te)) } function Ke() { return Fe(), Ae } function oe(t) { R.push(t) } const se = new Set; let P = 0; function Te() { if (P !== 0) return; const t = U; do { try { for (; P < D.length;) { const e = D[P]; P++, B(e), Xe(e.$$) } } catch (e) { throw D.length = 0, P = 0, e } for (B(null), D.length = 0, P = 0; ge.length;)ge.pop()(); for (let e = 0; e < R.length; e += 1) { const n = R[e]; se.has(n) || (se.add(n), n()) } R.length = 0 } while (D.length); for (; be.length;)be.pop()(); le = !1, se.clear(), B(t) } function Xe(t) { if (t.fragment !== null) { t.update(), I(t.before_update); const e = t.dirty; t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(oe) } } function Ye(t) { const e = [], n = []; R.forEach(r => t.indexOf(r) === -1 ? e.push(r) : n.push(r)), n.forEach(r => r()), R = e } const W = new Set; let F; function fe() { F = { r: 0, c: [], p: F } } function ae() { F.r || I(F.c), F = F.p } function A(t, e) { t && t.i && (W.delete(t), t.i(e)) } function T(t, e, n, r) { if (t && t.o) { if (W.has(t)) return; W.add(t), F.c.push(() => { W.delete(t), r && (n && t.d(1), r()) }), t.o(e) } else r && r() } function G(t) { return (t == null ? void 0 : t.length) !== void 0 ? t : Array.from(t) } function ee(t, e) { const n = {}, r = {}, i = { $$scope: 1 }; let c = t.length; for (; c--;) { const u = t[c], l = e[c]; if (l) { for (const s in u) s in l || (r[s] = 1); for (const s in l) i[s] || (n[s] = l[s], i[s] = 1); t[c] = l } else for (const s in u) i[s] = 1 } for (const u in r) u in n || (n[u] = void 0); return n } function te(t) { return typeof t == "object" && t !== null ? t : {} } function V(t) { t && t.c() } function q(t, e, n) { const { fragment: r, after_update: i } = t.$$; r && r.m(e, n), oe(() => { const c = t.$$.on_mount.map(Ce).filter(ce); t.$$.on_destroy ? t.$$.on_destroy.push(...c) : I(c), t.$$.on_mount = [] }), i.forEach(oe) } function M(t, e) { const n = t.$$; n.fragment !== null && (Ye(n.after_update), I(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = []) } function Ge(t, e) { t.$$.dirty[0] === -1 && (D.push(t), Fe(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31 } function ne(t, e, n, r, i, c, u = null, l = [-1]) { const s = U; B(t); const o = t.$$ = { fragment: null, ctx: [], props: c, update: S, not_equal: i, bound: pe(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(e.context || (s ? s.$$.context : [])), callbacks: pe(), dirty: l, skip_bound: !1, root: e.target || s.$$.root }; u && u(o.root); let f = !1; if (o.ctx = n ? n(t, e.props || {}, (p, g, ...a) => { const h = a.length ? a[0] : g; return o.ctx && i(o.ctx[p], o.ctx[p] = h) && (!o.skip_bound && o.bound[p] && o.bound[p](h), f && Ge(t, p)), g }) : [], o.update(), f = !0, I(o.before_update), o.fragment = r ? r(o.ctx) : !1, e.target) { if (e.hydrate) { const p = He(e.target); o.fragment && o.fragment.l(p), p.forEach(k) } else o.fragment && o.fragment.c(); e.intro && A(t.$$.fragment), q(t, e.target, e.anchor), Te() } B(s) } class re { constructor() { ie(this, "$$"); ie(this, "$$set") } $destroy() { M(this, 1), this.$destroy = S } $on(e, n) { if (!ce(n)) return S; const r = this.$$.callbacks[e] || (this.$$.callbacks[e] = []); return r.push(n), () => { const i = r.indexOf(n); i !== -1 && r.splice(i, 1) } } $set(e) { this.$$set && !Me(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1) } } const We = "4"; typeof window < "u" && (window.__svelte || (window.__svelte = { v: new Set })).v.add(We); const z = []; function Pe(t, e) { return { subscribe: ze(t, e).subscribe } } function ze(t, e = S) { let n; const r = new Set; function i(l) { if (J(t, l) && (t = l, n)) { const s = !z.length; for (const o of r) o[1](), z.push(o, t); if (s) { for (let o = 0; o < z.length; o += 2)z[o][0](z[o + 1]); z.length = 0 } } } function c(l) { i(l(t)) } function u(l, s = S) { const o = [l, s]; return r.add(o), r.size === 1 && (n = e(i, c) || S), l(t), () => { r.delete(o), r.size === 0 && n && (n(), n = null) } } return { set: i, update: c, subscribe: u } } function De(t, e, n) { const r = !Array.isArray(t), i = r ? [t] : t; if (!i.every(Boolean)) throw new Error("derived() expects stores as input, got a falsy value"); const c = e.length < 2; return Pe(n, (u, l) => { let s = !1; const o = []; let f = 0, p = S; const g = () => { if (f) return; p(); const h = e(r ? o[0] : o, u, l); c ? u(h) : p = ce(h) ? h : S }, a = i.map((h, d) => Ie(h, v => { o[d] = v, f &= ~(1 << d), s && g() }, () => { f |= 1 << d })); return s = !0, g(), function () { I(a), p(), s = !1 } }) } function Qe(t, e) { if (t instanceof RegExp) return { keys: !1, pattern: t }; var n, r, i, c, u = [], l = "", s = t.split("/"); for (s[0] || s.shift(); i = s.shift();)n = i[0], n === "*" ? (u.push("wild"), l += "/(.*)") : n === ":" ? (r = i.indexOf("?", 1), c = i.indexOf(".", 1), u.push(i.substring(1, ~r ? r : ~c ? c : i.length)), l += ~r && !~c ? "(?:/([^/]+?))?" : "/([^/]+?)", ~c && (l += (~r ? "?" : "") + "\\" + i.substring(c))) : l += "/" + i; return { keys: u, pattern: new RegExp("^" + l + (e ? "(?=$|/)" : "/?$"), "i") } } function Ze(t) { let e, n, r; const i = [t[2]]; var c = t[0]; function u(l, s) { let o = {}; if (s !== void 0 && s & 4) o = ee(i, [te(l[2])]); else for (let f = 0; f < i.length; f += 1)o = Ne(o, i[f]); return { props: o } } return c && (e = Z(c, u(t)), e.$on("routeEvent", t[7])), { c() { e && V(e.$$.fragment), n = K() }, m(l, s) { e && q(e, l, s), E(l, n, s), r = !0 }, p(l, s) { if (s & 1 && c !== (c = l[0])) { if (e) { fe(); const o = e; T(o.$$.fragment, 1, 0, () => { M(o, 1) }), ae() } c ? (e = Z(c, u(l, s)), e.$on("routeEvent", l[7]), V(e.$$.fragment), A(e.$$.fragment, 1), q(e, n.parentNode, n)) : e = null } else if (c) { const o = s & 4 ? ee(i, [te(l[2])]) : {}; e.$set(o) } }, i(l) { r || (e && A(e.$$.fragment, l), r = !0) }, o(l) { e && T(e.$$.fragment, l), r = !1 }, d(l) { l && k(n), e && M(e, l) } } } function et(t) { let e, n, r; const i = [{ params: t[1] }, t[2]]; var c = t[0]; function u(l, s) { let o = {}; if (s !== void 0 && s & 6) o = ee(i, [s & 2 && { params: l[1] }, s & 4 && te(l[2])]); else for (let f = 0; f < i.length; f += 1)o = Ne(o, i[f]); return { props: o } } return c && (e = Z(c, u(t)), e.$on("routeEvent", t[6])), { c() { e && V(e.$$.fragment), n = K() }, m(l, s) { e && q(e, l, s), E(l, n, s), r = !0 }, p(l, s) { if (s & 1 && c !== (c = l[0])) { if (e) { fe(); const o = e; T(o.$$.fragment, 1, 0, () => { M(o, 1) }), ae() } c ? (e = Z(c, u(l, s)), e.$on("routeEvent", l[6]), V(e.$$.fragment), A(e.$$.fragment, 1), q(e, n.parentNode, n)) : e = null } else if (c) { const o = s & 6 ? ee(i, [s & 2 && { params: l[1] }, s & 4 && te(l[2])]) : {}; e.$set(o) } }, i(l) { r || (e && A(e.$$.fragment, l), r = !0) }, o(l) { e && T(e.$$.fragment, l), r = !1 }, d(l) { l && k(n), e && M(e, l) } } } function tt(t) { let e, n, r, i; const c = [et, Ze], u = []; function l(s, o) { return s[1] ? 0 : 1 } return e = l(t), n = u[e] = c[e](t), { c() { n.c(), r = K() }, m(s, o) { u[e].m(s, o), E(s, r, o), i = !0 }, p(s, [o]) { let f = e; e = l(s), e === f ? u[e].p(s, o) : (fe(), T(u[f], 1, 1, () => { u[f] = null }), ae(), n = u[e], n ? n.p(s, o) : (n = u[e] = c[e](s), n.c()), A(n, 1), n.m(r.parentNode, r)) }, i(s) { i || (A(n), i = !0) }, o(s) { T(n), i = !1 }, d(s) { s && k(r), u[e].d(s) } } } function ye() { const t = window.location.href.indexOf("#/"); let e = t > -1 ? window.location.href.substr(t + 1) : "/"; const n = e.indexOf("?"); let r = ""; return n > -1 && (r = e.substr(n + 1), e = e.substr(0, n)), { location: e, querystring: r } } const de = Pe(null, function (e) { e(ye()); const n = () => { e(ye()) }; return window.addEventListener("hashchange", n, !1), function () { window.removeEventListener("hashchange", n, !1) } }); De(de, t => t.location); De(de, t => t.querystring); const we = ze(void 0); function nt(t) { t ? window.scrollTo(t.__svelte_spa_router_scrollX, t.__svelte_spa_router_scrollY) : window.scrollTo(0, 0) } function rt(t, e, n) { let { routes: r = {} } = e, { prefix: i = "" } = e, { restoreScrollState: c = !1 } = e; class u { constructor(m, b) { if (!b || typeof b != "function" && (typeof b != "object" || b._sveltesparouter !== !0)) throw Error("Invalid component object"); if (!m || typeof m == "string" && (m.length < 1 || m.charAt(0) != "/" && m.charAt(0) != "*") || typeof m == "object" && !(m instanceof RegExp)) throw Error('Invalid value for "path" argument - strings must start with / or *'); const { pattern: N, keys: L } = Qe(m); this.path = m, typeof b == "object" && b._sveltesparouter === !0 ? (this.component = b.component, this.conditions = b.conditions || [], this.userData = b.userData, this.props = b.props || {}) : (this.component = () => Promise.resolve(b), this.conditions = [], this.props = {}), this._pattern = N, this._keys = L } match(m) { if (i) { if (typeof i == "string") if (m.startsWith(i)) m = m.substr(i.length) || "/"; else return null; else if (i instanceof RegExp) { const C = m.match(i); if (C && C[0]) m = m.substr(C[0].length) || "/"; else return null } } const b = this._pattern.exec(m); if (b === null) return null; if (this._keys === !1) return b; const N = {}; let L = 0; for (; L < this._keys.length;) { try { N[this._keys[L]] = decodeURIComponent(b[L + 1] || "") || null } catch { N[this._keys[L]] = null } L++ } return N } async checkConditions(m) { for (let b = 0; b < this.conditions.length; b++)if (!await this.conditions[b](m)) return !1; return !0 } } const l = []; r instanceof Map ? r.forEach((_, m) => { l.push(new u(m, _)) }) : Object.keys(r).forEach(_ => { l.push(new u(_, r[_])) }); let s = null, o = null, f = {}; const p = Je(); async function g(_, m) { await Ke(), p(_, m) } let a = null, h = null; c && (h = _ => { _.state && (_.state.__svelte_spa_router_scrollY || _.state.__svelte_spa_router_scrollX) ? a = _.state : a = null }, window.addEventListener("popstate", h), Ue(() => { nt(a) })); let d = null, v = null; const H = de.subscribe(async _ => { d = _; let m = 0; for (; m < l.length;) { const b = l[m].match(_.location); if (!b) { m++; continue } const N = { route: l[m].path, location: _.location, querystring: _.querystring, userData: l[m].userData, params: b && typeof b == "object" && Object.keys(b).length ? b : null }; if (!await l[m].checkConditions(N)) { n(0, s = null), v = null, g("conditionsFailed", N); return } g("routeLoading", Object.assign({}, N)); const L = l[m].component; if (v != L) { L.loading ? (n(0, s = L.loading), v = L, n(1, o = L.loadingParams), n(2, f = {}), g("routeLoaded", Object.assign({}, N, { component: s, name: s.name, params: o }))) : (n(0, s = null), v = null); const C = await L(); if (_ != d) return; n(0, s = C && C.default || C), v = L } b && typeof b == "object" && Object.keys(b).length ? n(1, o = b) : n(1, o = null), n(2, f = l[m].props), g("routeLoaded", Object.assign({}, N, { component: s, name: s.name, params: o })).then(() => { we.set(o) }); return } n(0, s = null), v = null, we.set(void 0) }); Ve(() => { H(), h && window.removeEventListener("popstate", h) }); function X(_) { me.call(this, t, _) } function O(_) { me.call(this, t, _) } return t.$$set = _ => { "routes" in _ && n(3, r = _.routes), "prefix" in _ && n(4, i = _.prefix), "restoreScrollState" in _ && n(5, c = _.restoreScrollState) }, t.$$.update = () => { t.$$.dirty & 32 && (history.scrollRestoration = c ? "manual" : "auto") }, [s, o, f, r, i, c, X, O] } class it extends re { constructor(e) { super(), ne(this, e, rt, tt, J, { routes: 3, prefix: 4, restoreScrollState: 5 }) } } function st(t) { let e; return { c() { e = w("h1"), e.textContent = "Home" }, m(n, r) { E(n, e, r) }, p: S, i: S, o: S, d(n) { n && k(e) } } } class ve extends re { constructor(e) { super(), ne(this, e, null, st, J, {}) } } function ke(t, e, n) { const r = t.slice(); return r[11] = e[n], r } function Ee(t, e, n) { const r = t.slice(); return r[11] = e[n], r } function $e(t) { let e, n, r, i, c, u, l, s, o; return { c() { e = w("div"), n = w("p"), n.innerHTML = "<b>Analyzed Image:</b>", r = $(), i = w("img"), u = $(), l = w("button"), l.textContent = "Analyze", he(i.src, c = t[1]) || j(i, "src", c), j(i, "width", "300"), j(i, "alt", "preview"), j(l, "type", "button") }, m(f, p) { E(f, e, p), y(e, n), y(e, r), y(e, i), E(f, u, p), E(f, l, p), s || (o = xe(l, "click", t[9]), s = !0) }, p(f, p) { p & 2 && !he(i.src, c = f[1]) && j(i, "src", c) }, d(f) { f && (k(e), k(u), k(l)), s = !1, o() } } } function Oe(t) { let e, n = t[4].length > 0 && je(t); return { c() { n && n.c(), e = K() }, m(r, i) { n && n.m(r, i), E(r, e, i) }, p(r, i) { r[4].length > 0 ? n ? n.p(r, i) : (n = je(r), n.c(), n.m(e.parentNode, e)) : n && (n.d(1), n = null) }, d(r) { r && k(e), n && n.d(r) } } } function je(t) { let e, n, r, i, c, u, l, s, o = G(t[5]), f = []; for (let a = 0; a < o.length; a += 1)f[a] = Le(Ee(t, o, a)); let p = G(t[6]), g = []; for (let a = 0; a < p.length; a += 1)g[a] = Se(ke(t, p, a)); return { c() { e = w("p"), e.innerHTML = "<b>This fruit is most likely one of the following:</b>", n = $(); for (let a = 0; a < f.length; a += 1)f[a].c(); r = $(), i = w("br"), c = $(), u = w("p"), u.innerHTML = "<b>This fruit is most likely NOT one of the following:</b>", l = $(); for (let a = 0; a < g.length; a += 1)g[a].c(); s = K() }, m(a, h) { E(a, e, h), E(a, n, h); for (let d = 0; d < f.length; d += 1)f[d] && f[d].m(a, h); E(a, r, h), E(a, i, h), E(a, c, h), E(a, u, h), E(a, l, h); for (let d = 0; d < g.length; d += 1)g[d] && g[d].m(a, h); E(a, s, h) }, p(a, h) { if (h & 32) { o = G(a[5]); let d; for (d = 0; d < o.length; d += 1) { const v = Ee(a, o, d); f[d] ? f[d].p(v, h) : (f[d] = Le(v), f[d].c(), f[d].m(r.parentNode, r)) } for (; d < f.length; d += 1)f[d].d(1); f.length = o.length } if (h & 64) { p = G(a[6]); let d; for (d = 0; d < p.length; d += 1) { const v = ke(a, p, d); g[d] ? g[d].p(v, h) : (g[d] = Se(v), g[d].c(), g[d].m(s.parentNode, s)) } for (; d < g.length; d += 1)g[d].d(1); g.length = p.length } }, d(a) { a && (k(e), k(n), k(r), k(i), k(c), k(u), k(l), k(s)), _e(f, a), _e(g, a) } } } function Le(t) { let e, n, r = t[11].className + "", i, c, u, l, s = t[11].probability.toFixed(3) + "", o; return { c() { e = w("tr"), n = w("td"), i = x(r), c = x(":"), u = $(), l = w("td"), o = x(s) }, m(f, p) { E(f, e, p), y(e, n), y(n, i), y(n, c), y(e, u), y(e, l), y(l, o) }, p(f, p) { p & 32 && r !== (r = f[11].className + "") && Q(i, r), p & 32 && s !== (s = f[11].probability.toFixed(3) + "") && Q(o, s) }, d(f) { f && k(e) } } } function Se(t) { let e, n, r = t[11].className + "", i, c, u, l, s = t[11].probability.toFixed(3) + "", o, f; return { c() { e = w("tr"), n = w("td"), i = x(r), c = x(":"), u = $(), l = w("td"), o = x(s), f = $() }, m(p, g) { E(p, e, g), y(e, n), y(n, i), y(n, c), y(e, u), y(e, l), y(l, o), y(e, f) }, p(p, g) { g & 64 && r !== (r = p[11].className + "") && Q(i, r), g & 64 && s !== (s = p[11].probability.toFixed(3) + "") && Q(o, s) }, d(p) { p && k(e) } } } function lt(t) { let e, n, r, i, c, u, l, s, o, f, p, g, a, h, d, v, H, X, O = t[2] && $e(t), _ = t[3] && Oe(t); return { c() { e = w("div"), n = w("h1"), n.textContent = "Fruit-Classifier", r = $(), i = w("h5"), i.textContent = "Classifier created with DeepJavaLibrary (DJL)", c = $(), u = w("p"), u.textContent = "Upload a picture of one of the following fruits:", l = $(), s = w("ul"), s.innerHTML = "<li>Apple</li> <li>Banana</li> <li>Cherry</li> <li>Grapes</li> <li>Kiwi</li> <li>Mango</li> <li>Orange</li> <li>Strawberry</li>", o = $(), f = w("form"), p = w("div"), g = w("label"), g.textContent = "Upload picture with. Only .jpeg and .png are accepted", a = $(), h = w("input"), d = $(), O && O.c(), v = $(), _ && _.c(), j(g, "for", "exampleFormControlFile1"), j(h, "type", "file"), j(h, "accept", "image/png, image/jpeg"), j(h, "class", "form-control-file"), j(h, "id", "image"), j(h, "name", "image"), j(p, "class", "form-group"), j(e, "class", "container-fluid") }, m(m, b) { E(m, e, b), y(e, n), y(e, r), y(e, i), y(e, c), y(e, u), y(e, l), y(e, s), y(e, o), y(e, f), y(f, p), y(p, g), y(p, a), y(p, h), y(e, d), O && O.m(e, null), y(e, v), _ && _.m(e, null), H || (X = xe(h, "change", t[7]), H = !0) }, p(m, [b]) { m[2] ? O ? O.p(m, b) : (O = $e(m), O.c(), O.m(e, v)) : O && (O.d(1), O = null), m[3] ? _ ? _.p(m, b) : (_ = Oe(m), _.c(), _.m(e, null)) : _ && (_.d(1), _ = null) }, i: S, o: S, d(m) { m && k(e), O && O.d(), _ && _.d(), H = !1, X() } } } function ot(t, e, n) { let r, i, c = !1, u = !1, l = [], s = [], o = []; function f(a) { n(3, u = !1); const h = a.target.files; if (console.log(h), h.length !== 1) { alert("Bitte genau eine Datei hochladen."); return } if (h[0].size / 1024 / 1024 > 10) { alert("Datei zu groß (max. 10MB)"); return } n(2, c = !0), n(0, r = h), n(1, i = URL.createObjectURL(r[0])) } async function p(a) { const h = new FormData; h.append("image", a); try { const d = await fetch("/analyze", { method: "POST", body: h }); if (!d.ok) throw new Error("Failed to upload and classify the image"); n(4, l = await d.json()), n(5, s = []), n(6, o = []); for (const v of l) v.probability > .2 ? n(5, s = [...s, v]) : n(6, o = [...o, v]); n(3, u = !0) } catch (d) { console.error("Error:", d) } } return [r, i, c, u, l, s, o, f, p, () => p(r[0])] } class ct extends re { constructor(e) { super(), ne(this, e, ot, lt, J, {}) } } const ut = { "/": ve, "/home": ve, "/classifier": ct }; function ft(t) { let e, n, r, i, c, u; return c = new it({ props: { routes: ut } }), { c() { e = w("div"), n = w("nav"), n.innerHTML = '<div class="container-fluid"><a class="navbar-brand" href="#/">Home</a> <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button> <div class="collapse navbar-collapse" id="navbarNav"><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item"><a class="nav-link" aria-current="page" href="#/classifier">Classifier</a></li></ul></div></div>', r = $(), i = w("div"), V(c.$$.fragment), j(n, "class", "navbar navbar-expand-lg bg-light"), j(i, "class", "container"), j(e, "id", "app") }, m(l, s) { E(l, e, s), y(e, n), y(e, r), y(e, i), q(c, i, null), u = !0 }, p: S, i(l) { u || (A(c.$$.fragment, l), u = !0) }, o(l) { T(c.$$.fragment, l), u = !1 }, d(l) { l && k(e), M(c) } } } class at extends re { constructor(e) { super(), ne(this, e, null, ft, J, {}) } } new at({ target: document.getElementById("app") });